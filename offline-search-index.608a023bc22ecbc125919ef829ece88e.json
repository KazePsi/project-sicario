























[{"body":"This site holds the official documentation for Project Sicario, and how to build mods for the platform.\nPlease note that this site is specifically intended for mod authors looking to build mods for Sicario, not for users building mods. If you’re looking for a merged mod, head back to the app and start building!\nIf you’re looking for information on how to actually build a patch, or reimplement your existing blueprint mods as mergeable Sicario patches, then read through the docs using the sections on the left.\n For queries about these documentations or this Sicario server, please contact @agc93#0001 on Discord, or raise an issue on GitHub\n ","categories":"","description":"","excerpt":"This site holds the official documentation for Project Sicario, and …","ref":"/","tags":"","title":"Project Sicario Documentation"},{"body":"How To Build Sicario Patches At it’s simplest, a Project Sicario mod is just a JSON file with a specific structure and a different file extension.\n I’d recommend using a JSON-aware editor (I personally use VS Code) for this, since it might catch small errors and make authoring the patch objects easier.\n I think the easiest way to demonstrate how a Sicario patch works is to show you a simple one, so we’ll walk through a reasonably simple one: the AoA Unlocker\n","categories":"","description":"","excerpt":"How To Build Sicario Patches At it’s simplest, a Project Sicario mod …","ref":"/introduction/","tags":"","title":"Introduction"},{"body":"In general, there’s only one thing that PSM adds that skin makers should be aware of but it’s a big one: automatically adding skin slots to aircraft!\nIf you offer a PSM-compatible version of your skin, PSM users will not have to replace a vanilla skin slot or worry about compatibility as PSM will dynamically add a new skin slot to the relevant aircraft to use your skin when it builds a merged mod.\nNow, to do this does require a small change on your end, but it’s pretty easy so offering a PSM-compatible skin mod doesn’t require a lot of work.\nPacking The important thing is that PSM bases its skin slots on the path you use when packing your skin. Rather than the usual quagmire of inconsistent names and paths PSM uses a simple format to detect skins it needs to add a slot for:\nProjectWingman/Content/Assets/Skins/\u003cAIRCRAFT-NAME-HERE\u003e/\u003cYOUR-SKIN-NAME-HERE\u003e.uasset That’s it. You don’t need to change anything about your skin itself, just give it a unique name (so that it doesn’t conflict with other skins), cook it in the Content/Assets/Skins/\u003cAIRCRAFT-NAME-HERE\u003e path and pack it in the path as above.\nOkay, there is one gotcha: the \u003cAIRCRAFT-NAME-HERE\u003e. Since PSM can’t know the player-facing name of every aircraft in the game, it actually uses the aircraft names from the DB_Aircraft datatable. As of v1.0.4, check the table below for the correct name to use.\n An advantage of this approach is that this same pattern also works for custom aircraft. Want to add a skin for the Overpowered Sk.37 mod? Just use OP-37. Check with the author for the right name to use.\n Example So for example, you could pack a mod that includes a Content/Assets/Skins/SU-37/Splinter_Red.uasset and PSM will add a new skin slot to the Sk.37 for your skin. More importantly, if the user installs another skin mod that includes Content/Assets/Skins/SU-37/FederationFerris.uasset then PSM will add two slots to the Sk.37, one for the Splinter camo, one for the Ferris scheme.\nSame for if your PAK file includes multiple versions of a skin with different markings you could pack it like this:\nContent/Assets/Skins/MiG-29/Serdyukov-Federation.uasset Content/Assets/Skins/MiG-29/Serdyukov-Monarch.uasset Content/Assets/Skins/MiG-29/Serdyukov-Clean.uasset When PSM runs on the user’s install, it will add three slots to the MG-29 with each variant of those skins.\n That being said, please don’t go mad with variants. The game will almost certainly have a maximum number of slots, we just haven’t found it yet.\n Aircraft Names    In-Game Internal Name  In-Game Internal Name     T-21 T-21  T/F-4 TF-4E   MG-21 MiG-21  SV-37 AJS-37   F/E-4 F-4E  F/C-16 F-16C   CR.105 CF-105  Sk.25U Su-25   MG-31 MIG-31  F/D-14 F-14D   MG-29 MiG-29  Accipiter AV-8   F/E-18 F-18E  F/C-15 F-15C   Sk.27 SU-27  Sk.37 SU-37   F/S-15 F-15SMTD  VX-23 F-22   CHIMERA ACG-01  SP-34R SPEAR   PW-Mk.1 PW-001        You can even use custom skin slots in the same PAK as an embedded preset to include both a new skin slot and datatable changes\n ","categories":"","description":"","excerpt":"In general, there’s only one thing that PSM adds that skin makers …","ref":"/packaging/skins/","tags":"","title":"Packing Aircraft Skins"},{"body":"Things are a little trickier (but not dramatically so) for blueprint/datatable mods.\nThe most important thing is that your blueprint changes need to already be in a Sicario preset. If you’ve already done that, you’re 90% of the way there. If not check out the docs to build your changes as a Sicario preset.\nOnce you have your patch(es), it’s time to turn them into a preset. Don’t worry, it’s easy.\nPresets A preset file is just a collection of Sicario patches bundled into one standalone file including any inputs they need to run. Just like a patch file, a preset file is just a JSON file with a special extension: .dtp. At its most basic, here’s what a preset file looks like:\n{ \"modParameters\": {}, \"mods\": [] } The modParameters key is optional and can be used to specify any required parameters for the patches in your preset.\n The parameters work the same way as they do in the hosted Project Sicario app, just this way the merger doesn’t have to prompt for the values to use.\n The mods key is the important one and is an array of the patches included in the preset. Here is where you would put any patch(es) required for your mod to work. You can either add them as a single mod, or as several: that’s up to you.\nPackaging Once you have a preset, it’s time to get it in the hands of users. You have a couple of options for that.\nLoose Files You can always just upload your preset file (i.e. the dtm file) to Nexus/ModDB/Discord/wherever you want and let users download it directly. As long as it ends up in their ~mods folder, PSM will load and build the preset just fine.\nEmbedded in your mod This one is a tiny bit trickier but way cooler. When you go to pack your mod, you can pack your preset file into the PAK file itself and PSM will then unpack it from the PAK during merge and build with those patches. Your preset file can be packed anywhere in the PAK file as long as it’s in a folder named sicario. PSM will load and merge any .dtp files it find in a sicario folder anywhere in the PAK file.\nThat way, users will only have to download and install one file! Obviously, if your mod requires the changes from your patches then your mod will also then require PSM itself.\n You can even use an embedded preset alongside the custom skin slot support to include both a new skin slot and datatable changes\n ","categories":"","description":"","excerpt":"Things are a little trickier (but not dramatically so) for …","ref":"/packaging/mods/","tags":"","title":"Packing Datatable Mods"},{"body":"Asset patches are the most reliable kind of patch and the one most authors should be using for most scenarios as it allows you to directly edit datatables using the same names, properties and structures the game uses, but uses a unique syntax to express this without having to learn UE4 (or development!). The first section of these docs will walk you through creating asset patches and they are what I recommend most authors to use, so you can likely skip over the section on hex patches.\nHex patches (also referred to as file patches) are the older method of building datatable mods for Project Wingman. They involve directly editing the binary parts of game files, replacing certain bytes with new bytes (generally represented in hex form). This approach still works, and it still supported by Project Sicario, but is not recommended for most scenarios as it is less robust, more likely to break in case of game updates and is just generally kinda messy. With that in mind, Sicario was originally built with hex patching in mind so file patching is still very much supported and documentation for working with hex patches is still included.\n","categories":"","description":"","excerpt":"Asset patches are the most reliable kind of patch and the one most …","ref":"/patches/","tags":"","title":"Building a Project Sicario mod"},{"body":"The docs in this section will walk you through the basics of a Project Sicario mod, focussing on the basic structure and format of a Sicario mod file, specifically aimed at creating patches using the newer (and better) asset patching method.\nIf you’re new to this, I recommend working through the articles on the left one-by-one to get a feel for it.\n","categories":"","description":"","excerpt":"The docs in this section will walk you through the basics of a Project …","ref":"/patches/walkthrough/","tags":"","title":"Building an asset patch"},{"body":"Let’s dive into the deep end and use a reasonably simple example of a patch file to illustrate how an asset patch file works. There’s a complete example of a reasonably simple mod included below: the AoA Unlocker. This will probably seem like a lot but over the next few pages we’ll walk slowly through all the individual parts so you can get an idea of how the patches work and how you can build your own.\nThe AoA unlocker mod file { \"_meta\": { \"DisplayName\": \"AoA for All\" }, \"FilePatches\": {}, \"AssetPatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp\": [ { \"name\": \"AoA Unlock\", \"patches\": [ { \"description\": \"Set CanUseAoA to true\", \"template\": \"datatable:{'BaseStats*'}.{'CanUseAoA*'}\", \"value\": \"BoolProperty:true\", \"type\": \"propertyValue\" } ] } ] } }  Note that (for now), the FilePatches: {} object is still required, even if it’s not being used.\n Now let’s step through each part of this file, so you can see what each part does.\nPatch Metadata (_meta) The first thing you’ll usually find in a Sicario patch file is the _meta field, which is an object with a few optional properties:\n DisplayName: A user-friendly name to show for your mod Author: Take a guess what this one’s for hotshot Description: also self-explanatory  All three of these values will be shown to users so please don’t just put “do the thing” or fill them in with shitposting!\nThere is some more metadata you can optionally provide, but that’s covered later on.\nThe Asset Patches (AssetPatches) The AssetPatches object is the main “substance” of a Sicario patch. It is a dictionary grouping the files to be edited with sets of patches to be applied to that file.\n Note that to support auto-packing you need to include the game file as the full target path for the file you’re editing.\n In the example above, we have just one key in the object: ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp. This just means that DB_Aircraft.uexp will be the only file that this patch will be applied to and it will be packed in that specific path. Each file then has an array of “patch sets”.\nPatch Sets Patch Sets are mostly a logical organizational idea: they’re a way of organizing patches together. For example, if your mod is changing multiple stats for multiple planes, you might include each plane as a separate patch set. A patch set is just an object with name and an array of patches:\n{ \"name\": \"AoA Unlock\", \"patches\": [] } On it’s own a patch set doesn’t do much, that’s up to the actual patches in the set.\nPatch Set Grouping There is one important thing to note with patch sets: all the patches in a set are matched together. That means if one patch requires a previous change, or matches based on a value changed by a previous patch, they need to be in separate patch sets. For example, if you change the name of something and then want a later patch to find the property based on that new name, it needs to be in its own set.\nThis will make a bit more sense later on, but just keep it in mind if you’re making changes that rely on each other.\n The reason for this is both complex and simple: it was possible for a change from an earlier patch to then match a later patches template which was extremely confusing in practice.\n Patches Now we hit the real meat of a Sicario patch: the actual edit to make. Here’s the example for enabling AoA for all aircraft:\n{ \"description\": \"Set CanUseAoA\", \"template\": \"datatable:{'BaseStats*'}.{'CanUseAoA*'}\", \"value\": \"BoolProperty:true\", \"type\": \"propertyValue\" } In plain English, this object just tells Sicario “replace the value of any CanUseAoA properties with true”, but that’s probably not immediately obvious. Don’t worry, it’s not as complicated as it looks!\nTemplate and Value These are the actual values Sicario will be (respectively) looking for and inserting into the file. When it runs, Project Sicario will load the file into memory, parse the file (more on that later), look for any values that match the template value and then apply the value. How exactly the value is applied varies based on the patch type.\nIn short, the Template is how Sicario knows which properties to change (and not to change) and is used to isolate out exactly what you want to change. Templates are covered in more detail in the next section.\nThe Value of the patch, on the other hand, is how Sicario knows how you want to change it and is used to apply any number of potential changes based on the patch type. The patch value (and patch types) are also covered in more detail in a later section.\n","categories":"","description":"","excerpt":"Let’s dive into the deep end and use a reasonably simple example of a …","ref":"/patches/walkthrough/intro/","tags":"","title":"File Structure"},{"body":"If you oversimplify a UE4 cooked asset file (that’s Sicario’s job), they are essentially a collection of properties, some of them with their own properties and so forth. The template value is essentially a filter to control which properties the value is applied to, using a set of simplistic filters. The syntax can seem kinda of daunting but it’s not so bad once you understand how it works.\nThe basic format is this: a data type at the start, then a set of filters separated by .s.\nWhen it runs a patch, Sicario will load the file using the specified type, it will run every property in the file through the chain of filters and then run the actual patch type and value on all the matching properties.\nEach filter in the chain is run in order so only properties that match each step will be included in the final result.\nData Types The first thing in a template is the data type. As of writing there is only one supported data type: data tables, specified with the datatable: prefix. This loads the file as a UE4 DataTable, returning every row of the table as a named property.\nFilters This is the most daunting part to understand, but really isn’t as bad as it looks. Let’s explore this using our example mod: the AoA unlocker. Here’s that mod’s template:\ndatatable:{'BaseStats*'}.{'CanUseAoA*'} First off, the easy part: the type. The datatable: tells Sicario to load the file as a UE4 DataTable and returns every row. Next up is a set of filters separated by .s. In our case, both filters are doing the same thing: returning only the struct properties with a name that starts with a certain string, first off BaseStats. Next, the result of that filter (i.e. a bunch of properties named BaseStats) are passed into the second filter. That filter just returns any struct properties with a name that starts with CanUseAoA. All the properties that match that last filter are passed directly to the patch type to have the value modified.\nExample in Action If you’ve ever seen the DB_Aircraft file that this example patch is modifying, you’ll have noticed it looks something like this abridged sample:\n\"T-21\": { \"export_type\": \"RowStruct\", \"FamilyID_114_171BFD3F41B21A7C1797CE91CF694311\": \"mig21\", \"ID_101_9607548349D1C4AAC5D972B872BB91E4\": { // trimmed }, \"CQ_ID_149_53E0A3174FB70B3F9698058FB61388D9\": { //trimmed }, \"Price_77_50AB72FA43B3127002F5F893321A7AAA\": 0, // ...trimmed \"BoneDetails_46_F00ED91D4FDF91F973A7DAAF8A291DBF\": { \"PilotCount_2_65D06B7D492533AA2F8E9DA8254C5747\": 1, \"CondensationPoint_15_187804564BEB3AD239710AB3F72AABDF\": 0, // ...trimmed }, \"BaseStats_90_4FCD5FE44A06097FD9A455ACA4754B1E\": { \"RollInterpSpeed_28_C66FD5244EC8FBAE6B5EC9837FB70B1E\": 1.9, \"PitchInterpSpeed_29_90B4863F4DFF9111D073229AE0C909E9\": 2.1, \"YawInterpSpeed_30_272A70AB493C5265822667AFA304857C\": 1.5, \"MaxSpeed_31_58011513426ABC47552EEFA646C7E89A\": 2500.0, \"Acceleration_34_294F4BA04EA43CF04A560E82B90B7DFA\": 55.0, \"RollSpeed_39_E8C7F3914C6D3146D2166FAF21971CED\": 170.0, \"TurnSpeed_40_5254820C48D4E4E50EBD089AB8C2B12E\": 85.0, \"YawSpeed_37_33AA996848D24FBF807F609931FDC135\": 10.0, \"InterpSpeed_43_B02AFCF7418D3359B814BB9FA4E8DF9F\": 2.0, \"GearLiftVar_47_037DE3944066F0D58637388A1488C773\": 25.0, \"CannonType_50_D23A2D56429DB7C2FD1F3F9BD32989C9\": \"S_CannonType::NewEnumerator0\", \"CanUseAoA_52_927DA6AE426EEE21F9ECD7AF7E857628\": false, \"VTOL_54_FABB19354B444768DC73E1BF80437EA1\": false }, \"UIImage_83_026AA95649B0C45015114AAB80EDFCD4\": [\"mg21_icon\", \"/Game/Assets/Objects/Aircraft/Mig21/Textures/mg21_icon\"], \"HardpointSlots_122_9A810A7F449CEB12E0CD0C808A4D3162\": [2, 2], \"HardpointCompatibilityList_130_7BA5148945B4572A862CC0ACFFB7AB21\": [\"stdm\", \"0,droptank\"], // ...trimmed }, \"TF-4E\": { // ...trimmed } It should be a little clearer now that our {'BaseStats*'}.{'CanUseAoA*'} template will match and return the BaseStats_90_4FCD5FE44A06097FD9A455ACA4754B1E property for each aircraft, then the second filter will match and return the CanUseAoA_52_927DA6AE426EEE21F9ECD7AF7E857628 property for each aircraft. Now, just those properties will be run through the patch type to be updated.\nFilter Types Now, all the examples above were looking for the same thing: struct property types. The template syntax though, is a lot more flexible than that. To see what an extreme example looks like: here is another template.\ndatatable:['F-15C'].[0].{'HardpointSlots*'}.[[1]].\u003cIntProperty='2'\u003e Now if we step through this one again, you’ll see a few new filters, but the same basic idea:\n datatable: : Loads the file as a data table ['F-15C']: Matches any properties with a name of F-15C [0]: only returns the first match (arrays are numbered from zero). {'HardpointSlots*'}: returns properties from any matched structs with a name that starts with HardpointSlots [[1]]: Matches the second entry in a matching array property (rather than just the first match). \u003cIntProperty='2'\u003e: Only returns matching properties that are of an IntProperty type and have a value of 2.   The [] vs [[]] distinction can be tricky. The easiest summary is that [[]] matches the contents of an ArrayProperty, but [] just matches the first property it sees and returns the whole property\n Now that’s a lot of filters, the result of which is that out of the entire lengthy and complex DB_Aircraft datatable, that result returns exactly one thing: the unmodded second weapon hardpoint for the FC-15.\nWhile they can be tricky to make, a well-written template will ensure that you only change the values you want and can even ensure that you don’t overwrite modded values, allowing users to merge your patch with others better.\nAvailable Filters  Please note that this list may not be exhaustive: Sicario is designed to support additional filters easily\n Here’s a very brief summary of the available filters for use in templates:\n   Syntax Example Notes     [int] [0],[2] Matches the nth incoming result. Helpful for filtering duplicates, or Mk.1 planes   ['string'] ['F-15C'], ['MSSL'] Matches an incoming property with the given name. Doesn’t care what type it is or what properties it might have.   [[int]] [[1]] Matches the nth entry of incoming ArrayPropertys, returning the actual entry, not the array itself.   {'string'} {'BoneDetails*'}, {‘UnitType_2_2706’}` Matches a child property of a StructProperty by name, optionally with partial matching   \u003cstring\u003e \u003cIntProperty\u003e, \u003cStructProperty\u003e Matches only the incoming properties of the specific given type   \u003cstring=int\u003e \u003cIntProperty=2\u003e, \u003cFloatProperty=1.5\u003e Matches only incoming properties of the specific type and specific value   \u003cstring='string'\u003e \u003cStrProperty='saa,mlaa'\u003e Same as above, but for non-numeric types   \u003cstring::string\u003e \u003cS_CannonType::NewEnumerator2\u003e Matches only enum properties, with the right enum type and the right enum value    There’s also one special filter: [*]. That filter will just match everything and return all the properties it receives. This can be useful if you’re trying to match a whole datatable for example.\n","categories":"","description":"","excerpt":"If you oversimplify a UE4 cooked asset file (that’s Sicario’s job), …","ref":"/patches/walkthrough/template/","tags":"","title":"Understanding Property Templates"},{"body":"Patches Now we hit the real meat of a Sicario patch: the actual edit to make. Here’s the example for enabling AoA for all aircraft:\n{ \"description\": \"Set CanUseAoA\", \"template\": \"datatable:{'BaseStats*'}.{'CanUseAoA*'}\", \"value\": \"BoolProperty:true\", \"type\": \"propertyValue\" } In plain English, this object just tells Sicario “replace the value of any CanUseAoA properties with true”.\nTemplate and Value These are the actual values Sicario will be (respectively) looking for and inserting into the binary file. When it runs, Project Sicario will load the file into memory, parse the file (more on that below), look for any values that match the template value and then apply the value. How exactly the value is applied varies based on the patch type.\nTemplates are covered in more detail in the Property Templates section.\nTypes The two main types of patches currently in use are:\n   Type Notes     propertyValue This is by far the most common/useful and for good reason: it’s the most useful and versatile type. It sets the value of matching properties to the given value.   arrayPropertyValue Sibling type to propertyValue that creates/inserts an array value to the given properties using a simple array syntax   modifyPropertyValue Modifies a numeric value based on it’s existing value.   textProperty Specialized patch type for working UE4’s TextProperty fields more effectively.    Most of these types use a common convention for the value field: DataType:value. This ensures that the properties are set with the correct data types the game uses. Note that other patch types might not use the same convention.\nSpecial Patch Types The 4 patch types above will handle the vast majority of Sicario patches reasonably well, but there’s two patch types that deserve extra attention: objectRef and duplicateEntry\n Both of these are much more complex to get working right and I’d recommend you start with the simpler changes handled by the regular patch types.\n duplicateEntry and duplicateProperty This one is pretty powerful as its the most reliable way to add new properties to an existing object, by duplicating an existing property of an object. Adding a new property just requires matching the parent property, then specifying the source property’s name and and the duplicate property’s (unique) name.\nHere’s a patch that adds a new weapon based on the STDM:\n{ \"description\": \"Clone MSSL\", \"template\": \"datatable:[*]\", \"value\": \"'MSSL'\u003e'MSTM'\", \"type\": \"duplicateEntry\" } The template just matches the top-level datatable (i.e. all entries in the table) and the value follows the simple pattern of 'SourceName':'TargetName' so you can specify the row to be duplicated (i.e. the MSSL row) and what the new row should be named (MSTM). This will take a copy of the MSSL property data and add it as a new property to the end of the datatable.\n duplicateProperty follows the same logic but for duplicating properties on an object rather than the whole object. It’s a bit more niche.\n Note that as covered in the “Patch Set Grouping” section above, patch sets are matched together, so if you add a new property then want to match that property in later patches, make sure they’re in a separate patch set.\nobjectRef The objectRef patch type is used to change what object a property refers to. Internally, UE4 refers to objects using links that seem kind of convoluted on the surface: the property just has a number referring to an entry in the linked class list, which refers to another entry in the linked class list which then refers to an entry in the header list. That’s a mess, so the objectRef patch type will handle updating each of those parts in order.\nFor example, here’s a patch that changes what texture the first skin slot on the F-16C uses:\n{ \"description\": \"Change the default skin 1\", \"template\": \"datatable:['F-16C'].[0].{'SkinLibraryLegacy*'}.[[0]]\", \"value\": \"'F16Custom_01':'/Game/Assets/Objects/Aircraft/F16C/Textures/Skin/F16Custom_01'\", \"type\": \"objectRef\" } You’ll note that the template syntax is the same as always: just use the template that matches the linked property you want to change. The value syntax though is a little different, and can best be summed up as 'ObjectName':'ObjectPath'. Simply specify what object that property should link to and the patch type will handle updating the linked classes and header list.\n","categories":"","description":"","excerpt":"Patches Now we hit the real meat of a Sicario patch: the actual edit …","ref":"/patches/walkthrough/patches/","tags":"","title":"Understanding Patches and Patch Types"},{"body":"The docs in this section will walk you through the basics of a Project Sicario mod, focussing on the basic structure and format of a Sicario mod file, but specifically aimed at creating hex/binary patches. Note that this is a legacy (but supported) method and we don’t recommend using this unless required.\nIf you’re new to this, I recommend working through the articles on the left one-by-one to get a feel for it.\n","categories":"","description":"","excerpt":"The docs in this section will walk you through the basics of a Project …","ref":"/patches/walkthrough-hex/","tags":"","title":"Building a hex/binary patch"},{"body":"Modifiers So now you’ve seen one basic example, but just to expand on that, here’s another very simple Sicario patch to unlock all currently locked modifiers:\n{ \"_meta\": { \"DisplayName\": \"Unlock disabled modifiers\", \"Author\": \"agc93\", \"description\": \"Unlocks disabled modifiers. Note that these modifiers don't actually work in-game.\" }, \"AssetPatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/Modifiers/DB_Modifiers.uexp\": [ { \"name\": \"Unlock modifiers\", \"patches\": [ { \"description\": \"All modifiers available\", \"template\": \"datatable:{'Available*'}.\u003cBoolProperty='false'\u003e\", \"value\": \"BoolProperty:true\", \"type\": \"propertyValue\" } ] } ] }, \"FilePatches\": { } } You’ll see that the basic structure is essentially the same, just with different values for the files, as well as the details of the specific patch being applied.\nMSTM Weapon For a dramatically more complex example, you can see a few more of the moving parts in action together:\n{ \"_meta\": { \"displayName\": \"MSTM: Multiple-Launch Standard Missiles\", \"author\": \"agc93\", \"description\": \"Adds a new MSTM weapon: multiple-fire STDMs.\" }, \"filePatches\": {}, \"assetPatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/Weapons/DWeaponDB.uexp\": [{ \"name\": \"Add new weapon\", \"patches\": [{ \"description\": \"Clone MSSL\", \"template\": \"datatable:[*]\", \"value\": \"'MSSL'\u003e'MSTM'\", \"type\": \"duplicateEntry\" }] }, { \"name\": \"ID change\", \"patches\": [{ \"description\": \"Change mssl ID to mstm\", \"template\": \"datatable:['MSTM'].[0].{'ID*'}.\u003cStrProperty\u003e\", \"value\": \"StrProperty:'mstm'\", \"type\": \"propertyValue\" }, { \"description\": \"Change STDM name to MSTM\", \"template\": \"datatable:['MSTM'].[0].{'WeaponUIName*'}.\u003cTextProperty\u003e\", \"value\": \"TextProperty:'MSTM'\", \"type\": \"propertyValue\" }, { \"description\": \"Increases the MSTM max projectiles to 6\", \"template\": \"datatable:['MSTM'].{'MaxProjectile*'}.\u003cIntProperty=2\u003e\", \"value\": \"IntProperty:6\", \"type\": \"propertyValue\" }] } ] } }  Of particular note, you can see that the patch adding the MSTM is in its own patch set since they get processed set-by-set.\nOtherwise, the later patches wouldn’t match anything (since it wouldn’t exist yet)\n ","categories":"","description":"","excerpt":"Modifiers So now you’ve seen one basic example, but just to expand on …","ref":"/patches/walkthrough/example/","tags":"","title":"Example Mod"},{"body":"The AoA unlocker mod file { \"_meta\": { \"DisplayName\": \"AoA for All\" }, \"FilePatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp\": [{ \"name\": \"AoA Unlock\", \"patches\": [{ \"description\": \"Set CanUseAoA\", \"template\": \"00 48 02\", \"substitution\": \"01\" }] }] } } Now let’s step through each part of this file.\nPatch Metadata (_meta) The first thing you’ll usually find in a Sicario patch file is the _meta field, which is an object with a few optional properties:\n DisplayName: A user-friendly name to show for your mod Author: Take a guess what this one’s for hotshot Description: also self-explanatory  All three of these values will be shown to users so please don’t just put “do the thing” or fill them in with shitposting!\nThere is some more metadata you can optionally provide, but that’s covered later on.\nThe File Patches (FilePatches) The FilePatches object is the main “substance” of a Sicario patch. It is a dictionary grouping the files to be edited with sets of patches to be applied to that file.\n Note that to support auto-packing you need to include the game file as the full target path for the file you’re editing.\n In the example above, we have just one key in the object: ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp. This just means that DB_Aircraft.uexp will be the only file that this patch will be applied to and it will be packed in that specific path. Each file then has an array of “patch sets”.\nPatch Sets Patch Sets are a purely logical organizational idea: they’re just a way of organizing patches together. For example, if your mod is changing multiple stats for multiple planes, you might include each plane as a separate patch set. A patch set is just an object with name and an array of patches:\n{ \"name\": \"AoA Unlock\", \"patches\": [] } On it’s own a patch set doesn’t do anything, that’s up to the actual patches in the set.\nPatches Now we hit the real meat of a Sicario patch: the actual hex edit to make. Here’s the example for enabling AoA for all aircraft:\n{ \"description\": \"Set CanUseAoA\", \"template\": \"00 48 02\", \"substitution\": \"01\", \"type\": \"before\" } In plain English, this object just tells Sicario “replace the byte immediately before 00 48 02 with a 01”.\nTemplate and Substitution These are the actual values Sicario will be (respectively) looking for and inserting into the binary file. When it runs, Project Sicario will load the file into memory, look for any appearance of the template value and then apply the substitution. How exactly the substitution is applied varies based on the patch type.\nTypes The two main types of patches currently in use are:\n before: replaces the byte(s) before the template with the value of substitution. inPlace: replaces the entire template with the value of the substitution.   There is also a valueBefore type, but it’s only useful in niche scenarios\n In fact, we could have also shown the AoA patch above with an inPlace patch:\n{ \"description\": \"Set CanUseAoA\", \"template\": \"00 00 48 02\", \"substitution\": \"01 00 48 02\", \"type\": \"inPlace\" } To translate, this patch just tells Sicario “replace every occurrence of the byte pattern 00 00 48 02 with the byte pattern 01 00 48 02”. These two examples serve essentially the same purpose, so choose the patch type that makes the most sense.\nThat being said, you should place a preference towards using inPlace: users will be shown a warning when including a before type patch since they ignore load order and could undo changes from another patch.\n","categories":"","description":"","excerpt":"The AoA unlocker mod file { \"_meta\": { \"DisplayName\": \"AoA for All\" }, …","ref":"/patches/walkthrough-hex/intro/","tags":"","title":"File Structure"},{"body":"So now you’ve seen one basic example, but just to expand on that, here’s another very simple Sicario patch to unlock all currently locked modifiers:\n{ \"_meta\": { \"DisplayName\": \"Unlock disabled modifiers\", \"Author\": \"agc93\", \"description\": \"Unlocks disabled modifiers. Note that these modifiers don't actually work in-game.\" }, \"FilePatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/Modifiers/DB_Modifiers.uexp\": [ { \"name\": \"Unlock modifiers\", \"patches\": [ { \"description\": \"All modifiers available\", \"template\": \"00 00 1E\", \"substitution\": \"01 00 1E\", \"type\": \"inPlace\" } ] } ] } } You’ll see that the basic structure is essentially the same, just with different values for the files, as well as the details of the specific patch being applied.\n","categories":"","description":"","excerpt":"So now you’ve seen one basic example, but just to expand on that, …","ref":"/patches/walkthrough-hex/example/","tags":"","title":"Example Mod"},{"body":"Now while that will work fine for simple things, sometimes you might not want to change every appearance of a key with its substitution. This is where the special window object on the patch becomes important.\nHere’s what it looks like in action:\n{ \"_meta\": { // removed for brevity }, \"FilePatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp\": [ { \"name\": \"Prez Unlock\", \"patches\": [ { \"description\": \"Set Pilot count to 2\", \"template\": \"00 00 00 00 1C 01\", \"substitution\": \"02 00 00 00 1C 01\", \"type\": \"inPlace\", \"window\": { \"after\": \"text:PW-Mk.I\", \"before\": \"text:MG-21\" } } ] } ] } } In short, the window object is a method of narrowing down what values should be replaced in a file. In the example above, we want to replace 00 00 00 00 1C 01 with 02 00 00 00 1C 01, but only for the PW Mk.I. To do that, we add a window object and specify that we only want to match occurrences of 00 00 00 00 1C 01 if they come after an appearance of the text “PW-Mk.I” and before an appearance of the text “MG-21”. This will narrow the search down to only the PW Mk.I’s part of the blueprint, ensuring we only change the PilotCount (i.e. 00 00 00 1C 01) for that one plane.\n Sicario will automatically substitute a string value for its binary/hex representation if it starts with the special text: prefix. So you could add text:F/E-4 and Sicario will automatically change that to 46 2F 45 2D 34 for you.\n Note that you can also omit the before key and only use an after to narrow down the search, but the reverse is not true! If you use a before, you must have an after to make a window.\n","categories":"","description":"","excerpt":"Now while that will work fine for simple things, sometimes you might …","ref":"/patches/walkthrough-hex/windowing/","tags":"","title":"Windowing matches"},{"body":"Since the basics we’ve outlined so far will only be effective for the simplest of use cases, Sicario also has a complete templating engine built-in and integrated into the mod format.\nWhile that might sound complicated, it only needs to be as complicated as you want it to be: all the templating features are optional and you can just use which parts you want/need/feel comfortable with.\nAs with the previous section, I recommend working through the articles on the left one-by-one to get a feel for this feature.\nSyntax and Features All the templating features in Project Sicario are built and rendered using the Liquid templating engine so if you’re unsure of the syntax or want to see how it works, you can always just check the Liquid docs (or the specific implementation we use)\n","categories":"","description":"","excerpt":"Since the basics we’ve outlined so far will only be effective for the …","ref":"/templating/","tags":"","title":"Using templates in your mods"},{"body":"Filters are one of the most useful parts of the Liquid template engine we’re using since it allows you to write some or all of your mod files in more “natural” formats then have Sicario convert it to the underlying hex for you.\nBasics The Liquid filter syntax looks like this:\n{{ someValue | filterName }} In short, you want to pipe (i.e. |) a value through one or more filters to get a result.\nExample Let’s look at a simple example: text. In an earlier example we saw using the special text: syntax to use a raw string in a match rather than having to convert it to hex first. You can do this with filters too! To reuse the example:\n{ \"_meta\": { // removed for brevity }, \"FilePatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp\": [ { \"name\": \"Prez Unlock\", \"patches\": [ { \"description\": \"Set Pilot count to 2\", \"template\": \"00 00 00 00 1C 01\", \"substitution\": \"02 00 00 00 1C 01\", \"type\": \"inPlace\", \"window\": { \"after\": \"{{ 'PW-Mk.I' | string }}\", \"before\": \"{{ 'MG-21' | string }}\" } } ] } ] } } You’ll see that in our window.after and window.before we could use the original string, run it through the string filter and Sicario will automatically change those values to their hex equivalents. Do take note that string values (like MG-21) do need to be quoted when they’re used in a template (i.e. 'MG-21 in the example above).\nHex/Binary Number Conversions  Obviously this is only relevant for mods using the old-style hex patches. Asset patches don’t need to convert to hex first.\n One of the other most common uses for Sicario’s filters is for converting different numbers to hex automatically. For example, if you wanted to change every plane with a RollInterpSpeed statistic of 2 to 2.5, you could use this patch:\n{ \"description\": \"Set RollInterpSpeed\", \"template\": \"{{ 2 | float }}D5 01 00 00 00 00\", \"substitution\": \"{{ 2.5 | float }}D5 01 00 00 00 00\", \"type\": \"inPlace\" } When the patch is run, Sicario will automatically convert 2, to its appropriate hex equivalent as a floating point value, and likewise for 2.5. So that patch will effectively “become”:\n{ \"description\": \"Set RollInterpSpeed\", \"template\": \"00 00 00 40 D5 01 00 00 00 00\", \"substitution\": \"00 00 20 40 D5 01 00 00 00 00\", \"type\": \"inPlace\" } ","categories":"","description":"","excerpt":"Filters are one of the most useful parts of the Liquid template engine …","ref":"/templating/filters/","tags":"","title":"Filters and conversions"},{"body":"For convenience, Project Sicario has a lot of non-standard filters available for patch files to use that will make a lot of actions much simpler. In no particular order, they are summarized below:\nNumber Types Filters are available for all the commonly used number types to automatically convert them to their respective hex representation:\n{{ 5.5 | float }} {{ 2 | int }} # 4-byte int32 {{ 250 | byte }} # 1-byte uint8 {{ 2 | mult: 2 | float }} # will multiply by the given value Boolean Filters There’s also a few for more easily dealing with boolean states:\n{{ \"true\" | bool }} # will return 00 or 01 (01 in this case) {{ \"false\" | not }} # inverts, returns \"true\" {{ \"true\" | not | bool }} # inverts and converts, returns 00 Blueprint Filters There’s also one very powerful filter specific to working with Blueprint edits: the row filter.\nThis one is used where the binary includes a string that’s prefixed by the string’s length. Most notably for Project Wingman, this is how loadouts are stored. The row filter will include the length of the final string and convert the whole thing to its hex:\n{{ \"0,stdm,saa,mlaa\" | row }} { \"description\": \"Add weapons to second slot\", \"template\": \"{{ \\\"0,saa,mlaa,mlag\\\" | row }}\", \"substitution\":\"{{ \\\"0,mlaa,saa\\\" | row }}\", \"type\": \"inPlace\" } Random Filter This one is a little trickier to use than the other due to some technical issues we faced. In short, this filter will generate a random number in a specific range.\n{ \"description\": \"Replaces 35 HP (so many planes) with random 10-100 value\", \"template\": \"{{ 35 | float }}7F 00 00 00 00 00 00 00 73\", \"substitution\": \"{{ 10 | random: 100 | float }}7F 00 00 00 00 00 00 00 73\", \"type\": \"inPlace\" } This will generate a random value between 10 (the input value) and 100 (the first argument) that you can then pass through the float filter to get the correct type.\n","categories":"","description":"","excerpt":"For convenience, Project Sicario has a lot of non-standard filters …","ref":"/templating/availablefilters/","tags":"","title":"Available Filters in Templates"},{"body":"This is a little more niche and mostly just used to save time while building patches, but Sicario also supports storing and retrieving variables in templates.\nDefining Variables To define your variables, you can add a top-level key called _vars to your file and add your variables with name and value to that:\n{ \"_meta\": { // removed for brevity }, \"_vars\": { \"weaponList\": \"'0,saa,mlaa'\" }, \"assetPatches\": { //removed for brevity } } Then, your patches can retrieve that value using vars.variableNameHere in a template:\n{ \"_vars\": { \"weaponList\": \"'0,saa,mlaa'\" }, \"filePatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp\": [ { \"name\": \"WeaponsChanges\", \"patches\": [{ \"description\": \"Give FC16 the chosen weapons\", \"template\": \"datatable:['F-16C'].{'HardpointCompatibilityList*'}.[[1]]\", \"value\": \"StrProperty:{{ vars.weaponList }}\", \"type\": \"propertyValue\" }] }, ] } } ","categories":"","description":"","excerpt":"This is a little more niche and mostly just used to save time while …","ref":"/templating/variables/","tags":"","title":"Template Variables"},{"body":" Obviously this is only relevant for mods using the old-style hex patches. Asset patches don’t need any of this and can use the property names directly.\n This is a little more niche and mostly just used to save time while building patches, but Sicario also supports a handful of the most commonly used blueprint “delimiters” available as vars in your patches.\nThe variables are generally available as BlueprintName.PropertyName so, for example, DB_Aircraft.MaxSpeed or DWeaponDB.ReloadTime.\nThe complete list of currently available variables is included below.\nUsage Example To use an example, here’s how a patch might change the turn speed and roll speed statistics of a playable aircraft:\n{ \"_meta\": { //...trimmed for brevity }, \"filePatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp\": [ { \"name\": \"Stat Changes\", \"patches\": [ { \"description\": \"Set RollSpeed\", \"template\": \"{{180|float}}{{DB_Aircraft.RollSpeed}}\", \"substitution\": \"{{350|float}}{{DB_Aircraft.RollSpeed}}\", \"type\": \"inPlace\", \"window\": { \"after\": \"text:Sk.37\", \"before\": \"text:F-15SMTD\" } } { \"description\": \"Set TurnSpeed\", \"template\": \"{{95|float}}{{DB_Aircraft.TurnSpeed}}\", \"substitution\": \"{{180|float}}{{DB_Aircraft.TurnSpeed}}\", \"type\": \"inPlace\", \"window\": { \"after\": \"text:Sk.37\", \"before\": \"text:F-15SMTD\" } } ] } ] } } Available Variables  The list below was updated as of 15/6/21.\n  Ignore the values of the keys below as they may be out of date, simply refer to the variable names.\n [DB_Aircraft] Available = Unlocked = Purchased = Sellable = DemoOverride = DemoUnlocked = CQ_Available = CQ_Unlocked = CQ_Purchased = CQ_Level = CQ_Price = RequiresCampaignFinish = Price = HasGun = PilotCount = EngineCount = DisableAfterburner = RollInterpSpeed = PitchInterpSpeed = YawInterpSpeed = MaxSpeed = Acceleration = RollSpeed = TurnSpeed = YawSpeed = InterpSpeed = GearLiftVar = CannonType = CanUseAOA = VTOL = Region = FixedLoadout = [DWeaponDB] WeaponAmmo = ReloadTime = MaxProjectile = MaxMultiLock = TargetType = LockonRange = FiringType = SalvoMaxMultiLock = IsAvailable = CQOnly = [DAirUnitNPC] MinSpeed = DefaultSpeed = MaxSpeed = Acceleration = RollSpeed = TurnSpeed = YawSpeed = BaseHP = [DB_AirshipData] CruiseSpeed = [DB_ProjectWingmanLevelList] Available = IsCampaignLevel = MissionCompletionBonus = [DB_GroundUnit] ScoreValue = [CQ_AlliedSquadBuyTable] UnitLimit = InitialCost = SubsequentCost = CordiumCost = UpgradeCost = ","categories":"","description":"","excerpt":" Obviously this is only relevant for mods using the old-style hex …","ref":"/templating/builtinvars/","tags":"","title":"Commonly Used Variables"},{"body":"As we covered in the earlier sections, you can provide some very basic metadata on your mod in the special _meta object. There’s actually a few extra bits of information you can also optionally provide, that will be covered in more detail below.\nIt is worth noting that most of this information is only relevant to the hosted Project Sicario app, not to the merger (PSM). The merger is designed to run without user interaction so if you’re only expecting to be supporting PSM users, you can skip most of this.\n_meta As a refresher, the _meta object is a simple object just allows you to add a little metadata about your patch mod that will be shown to users. The displayName (as you’d guess) is the name that is shown to users. You can also include a description key in this object if you’d like (it’s not required though). The author field is used to show the author of a patch mod, but note that if you upload your mod to a Sicario server, the author field will be overwritten (to prevent impersonation).\n_sicario The _sicario object is where we put app-specific metadata about your mod. The most important/common ones will be group, private and preview\n   Key Type Meaning     group string Used to group multiple mods together in the UI   private bool Only available to the uploader   preview bool Marks a mod as preview/unstable   overwrites bool Marks a mod as ignoring load order    All of these properties are optional.\nGroup (group) \"_sicario\": { \"group\": \"NPC Tweaks\" } Including a group will tell Sicario to visually group matching mods together in the UI. This is optional and should only be used where it makes sense, or you will risk your mod being completely hidden from users\nPrivate (private) \"_sicario\": { \"private\": true } Marking a mod as private means it will only be visible to the uploader, not to other users. Note that uploaded mods will often be automatically set to private and that private mods are (obviously) only visible while signed in.\nPreview/Unstable (preview) \"_sicario\": { \"preview\": true } Marking a mod as preview effectively flags it as potentially incomplete or unstable. These mods (whether public or private) will be hidden by default, but can be enabled from the build view.\nOverwrites (overwrites) \"_sicario\": { \"overwrites\": true } This is a convenience flag that Sicario uses internally, and that it will show to the user to warn them if a patch might overwrite other mods. I’d urge patch authors to set this flag if their mod changes properties without checking current values.\n","categories":"","description":"","excerpt":"As we covered in the earlier sections, you can provide some very basic …","ref":"/metadata/","tags":"","title":"Including Extended Metadata"},{"body":"There’s a lot of genuinely powerful, but also much more complex, patch features available in Project Sicario too.\nMy strong suggestion is to get very comfortable with all the features we’ve already outlined before you try and tackle the advanced features in your own mods.\n","categories":"","description":"","excerpt":"There’s a lot of genuinely powerful, but also much more complex, patch …","ref":"/templating/advanced/","tags":"","title":"Advanced Features"},{"body":"For some more complex cases, you might need to get user input to control how your patches are applied or change the values you’re using in your patches. For this reason, Sicario supports some basic input types that will be shown to users when they enable your mod in a build process.\nDefining Inputs Inputs need to be separately defined in a special _inputs key in your mod file:\n{ \"_meta\": { //trimmed for brevity }, \"_inputs\": [ { \"id\": \"uniqueIdHere\", \"type\": \"number\", \"message\": \"This will be shown to users\", \"default\": \"5\" // REQUIRED } ], \"FilePatches\": { //trimmed for brevity } } When the user enables a mod that defines inputs, Sicario will show a collection of input fields (grouped by mod) for the user to enter their own values. The message field is what will be shown to users, and you must define a default value or the input may not be shown or parsed correctly.\nUsing Inputs Now that’s easy but where do those values go? They are available in any templated fields!\nThe id of your input is the important part as that will be how you access your input’s final value in the patch definition. For example, if we define this input:\n\"_inputs\": [ { \"id\": \"customRollRate\", \"type\": \"number\", \"message\": \"Enter a turn rate\", \"default\": \"200\" //note that this is always a string! } ] We can then use the value from this input in a patch with a template, the special inputs object and the id of our input:\n\"ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp\": [ { \"name\": \"Stat Changes\", \"patches\": [ { \"description\": \"Set RollSpeed for all aircraft\", \"template\": \"datatable:{'BaseStats*'}.{'RollSpeed*'}\", \"value\": \"FloatProperty:{{inputs.customRollRate}}\", \"type\": \"propertyValue\" } ] } ] } ","categories":"","description":"","excerpt":"For some more complex cases, you might need to get user input to …","ref":"/templating/advanced/input/","tags":"","title":"Working with user input"},{"body":"In some circumstances you might only want to run a certain step under certain conditions, or to provide options to skip certain patches in a mod.\n In general, you should strongly preference using separate mod files for different patches. Conditional steps are only intended for very specific niche cases. Site owners may remove mods if they are abusing inputs/conditionals.\n Conditional patches allow you to only enable an entire patch set if a certain condition is met. The condition can be based on anything: constants, variables, inputs or any combination of those.\nDefinining Conditions Conditional patches are (a little counter-intuitively) defined completely separate from the patches they are controlling.\n The reasons for this are honestly sort of complicated but short version, this is how it works and will not be merged in future.\n For the sakes of this document, let’s look at this complete mod file:\n{ \"_meta\": { \"displayName\": \"Demo-Style FE-18\", \"author\": \"agc93\", \"description\": \"Adds STDMs to all slots for the F/E-18 and enables multilock\" }, \"_inputs\": [ { \"id\": \"horneyMultilock\", \"type\": \"boolean\", \"message\": \"Include STDM multilock\", \"default\": \"true\" } ], \"_sicario\": { \"enableSteps\": { \"MaxMultiLock\": \"{{ inputs.horneyMultilock }}\" } }, \"assetPatches\": { \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/AircraftData/DB_Aircraft.uexp\": [ { \"name\": \"Loadout\", \"patches\": [{ \"description\": \"Add weapons to first spw slot\", \"template\": \"datatable:['F-18E'].[0].{'HardpointCompatibilityList*'}.[[1]].\u003cStrProperty='0,saa,mlaa'\u003e\", \"value\": \"StrProperty:'0,saa,mlaa,stdm'\", \"type\": \"propertyValue\" }] } ], \"ProjectWingman/Content/ProjectWingman/Blueprints/Data/Weapons/DWeaponDB.uexp\": [ { \"name\": \"MaxMultiLock\", \"patches\": [{ \"description\": \"Ups the STDM max projectiles to 10\", \"template\": \"datatable:['MSSL'].{'MaxProjectile*'}.\u003cIntProperty:'2'\u003e\", \"value\": \"IntProperty:10\", \"type\": \"propertyValue\" }] } ] }, \"filePatches\":{} } You’ll see the familiar combinations of _meta, _inputs and filePatches, but you’ll see a new object in _sicario.enableSteps. That object is a dictionary that matches the name of a patch set to the condition controlling whether it should run.\nEvaluating Conditionals The shortest possible explanation for this logic is that the patch set with the specified name will only be included in the final mod if and only if the condition specified on the right evaluates to a boolean true. In practice, that means the result of any values or templates in the condition should return the string “true” or “false”. Returning true means the patch set will be included, returning false means the patch set will be ignored.\n If a patch set doesn’t appear in the enableSteps object at all, it will still be included by default.\n As mentioned, you can use all the usual features in the patch sets conditional including templates, filters, inputs, and variables. You can see that in the example above where the value of an input is directly controlling the inclusion of a patch set. While that’s probably the simplest case, there’s also plenty of other ways to control whether a set is enabled using all the features we’ve covered previously.\nUsage It is worth reiterating again that conditional patches should be a a very niche and/or last-resort feature. In general, you should use multiple mod files to create variants of a mod. For example, OP Weapons is built as 6 separate files so that users can most easily opt-in or opt-out of individual changes. This also makes Sicario’s job easier since changes are applied mod-by-mod.\nConditional patches should only be used in very specific scenarios where a small change that cannot be defined separately may have a large impact on the final mod.\n","categories":"","description":"","excerpt":"In some circumstances you might only want to run a certain step under …","ref":"/templating/advanced/enablesteps/","tags":"","title":"Making patches conditional"},{"body":"Epsecially with the introduction of PSM, it’s never been easier to make your mods Sicario-compatible. What that entails will be a little different based on what you’re building so check the relevant links on the left to see how you can build your mods to make the most of PSM’s capabilities.\nAs with the previous section, I recommend working through the articles on the left one-by-one to get a feel for this feature.\n","categories":"","description":"","excerpt":"Epsecially with the introduction of PSM, it’s never been easier to …","ref":"/packaging/","tags":"","title":"Packaging your mods"}]